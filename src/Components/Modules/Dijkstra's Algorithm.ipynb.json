{"cells":[{"cell_type":"code","execution_count":null,"id":"e5d32c24","metadata":{"id":"e5d32c24"},"outputs":[],"source":["import collections, heapq\n","\n","class Graph():\n","    def __init__(self, nodes, edges):\n","        self.nodes = nodes\n","        self.G = collections.defaultdict(lambda: [False,False,[],[]]) # Explored (bool), Added to queue, array of distances, array of outgoing edges\n","        for edge in edges:\n","            # edge: [from, to, distance]\n","            self.G[edge[0]][3].append(edge[1])\n","            self.G[edge[0]][2].append(edge[2])\n","    def dijkstra(self, S):\n","        queue = [(0, S)]\n","        A = collections.defaultdict(lambda: float('inf')); A[S] = 0; B = collections.defaultdict(list); B[S] = [S]\n","        while queue:\n","            S_d, S = heapq.heappop(queue)\n","            if self.G[S][0]: continue # seen before\n","            \n","            self.G[S][0] = True; print(\"S:\",S)\n","            for index, V in enumerate(self.G[S][3]): \n","                if not self.G[V][0]:\n","                    print(V)\n","                    d = self.G[S][2][index]\n","                    heapq.heappush(queue, (A[S]+d, V)) \n","                    print(A[V], A[S], d)\n","                    if A[V] > A[S] + d:\n","                        A[V] = A[S] + d\n","                        B[V] = B[S] + [V]\n","        return A, B"]},{"cell_type":"code","execution_count":null,"id":"abde4c43","metadata":{"id":"abde4c43"},"outputs":[],"source":["nodes = 5\n","edges = [('a','b',2),\n","         ('a','c',8),\n","         ('b','c',4),\n","         ('c','d',1),\n","         ('b','d',2),\n","         ('b','e',3),\n","         ('d','e',4)]\n","G = Graph(nodes, edges)"]},{"cell_type":"code","execution_count":null,"id":"7bfaabb0","metadata":{"id":"7bfaabb0"},"outputs":[],"source":["nodes = 4\n","edges = [('s','v',1),\n","         ('s','w',4),\n","         ('v','w',2),\n","         ('w','t',3),\n","         ('v','t',6)]\n","G = Graph(nodes, edges)"]},{"cell_type":"code","execution_count":null,"id":"0dba4f1c","metadata":{"id":"0dba4f1c"},"outputs":[],"source":["nodes = 3\n","edges = [('s','v',1),\n","         ('v','t',-5),\n","         ('s','t',-2)]\n","G = Graph(nodes, edges)"]},{"cell_type":"code","execution_count":null,"id":"fd9c5e58","metadata":{"id":"fd9c5e58"},"outputs":[],"source":["nodes = 5\n","edges = [[0,1,10],[0,4,3],[1,2,2],[1,4,4],[2,3,9],[3,2,7],[4,1,1],[4,2,8],[4,3,2]]\n","G = Graph(nodes, edges)"]},{"cell_type":"code","execution_count":null,"id":"a004f7a1","metadata":{"id":"a004f7a1","outputId":"807c1482-b960-48b3-8e45-c4f50cd08bf1"},"outputs":[{"name":"stdout","output_type":"stream","text":["S: a\n","b\n","inf 0 2\n","c\n","inf 0 8\n","S: b\n","c\n","8 2 4\n","d\n","inf 2 2\n","e\n","inf 2 3\n","S: d\n","e\n","5 4 4\n","S: e\n","S: c\n"]}],"source":["A, B = G.dijkstra('a')"]},{"cell_type":"code","execution_count":null,"id":"6a370a77","metadata":{"id":"6a370a77","outputId":"abe1048c-50b5-4904-a557-70069829318a"},"outputs":[{"data":{"text/plain":["[('a', 0), ('b', 2), ('c', 6), ('d', 4), ('e', 5)]"]},"execution_count":7,"metadata":{},"output_type":"execute_result"}],"source":["sorted(A.items(), key = lambda item: item[0])"]},{"cell_type":"code","execution_count":null,"id":"4f07c924","metadata":{"id":"4f07c924","outputId":"88d72173-cb96-4981-d9c0-459f9904d6f2"},"outputs":[{"data":{"text/plain":["defaultdict(list,\n","            {'s': ['s'],\n","             'v': ['s', 'v'],\n","             'w': ['s', 'v', 'w'],\n","             't': ['s', 'v', 'w', 't']})"]},"execution_count":109,"metadata":{},"output_type":"execute_result"}],"source":["B"]},{"cell_type":"code","execution_count":null,"id":"50709872","metadata":{"id":"50709872"},"outputs":[],"source":["import collections, heapq\n","\n","class Graph():\n","    def __init__(self, nodes, edges = []):\n","        self.nodes = nodes\n","        self.G = collections.defaultdict(lambda: [False,False,[],[]]) # Explored (bool), Added to queue, array of distances, array of outgoing edges\n","        for edge in edges:\n","            # edge: [from, to, distance]\n","            self.G[edge[0]][3].append(edge[1])\n","            self.G[edge[0]][2].append(edge[2])\n","            \n","    def add_edge(self, to_, from_, cost, bidirectional = False):\n","        self.G[from_][3].append(to_)\n","        self.G[from_][2].append(cost)\n","        if bidirectional:\n","            self.G[to_][3].append(from_)\n","            self.G[to_][2].append(cost)\n","    \n","    def dijkstra(self, S):\n","        queue = [(0, S)]\n","        A = collections.defaultdict(lambda: 1000000); A[S] = 0; B = collections.defaultdict(list); B[S] = [S]\n","        while queue:\n","            S_d, S = heapq.heappop(queue)\n","            if self.G[S][0]: continue # seen before\n","            \n","            self.G[S][0] = True#; print(\"S:\",S)\n","            for index, V in enumerate(self.G[S][3]): \n","                if not self.G[V][0]:\n","                    d = self.G[S][2][index]\n","                    heapq.heappush(queue, (A[S]+d, V)) \n","                    if A[V] > A[S] + d:\n","                        A[V] = A[S] + d\n","                        B[V] = B[S] + [V]\n","        return A, B"]}],"metadata":{"kernelspec":{"display_name":"Python 3 (ipykernel)","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.9.7"},"colab":{"name":"Dijkstra's Algorithm.ipynb","provenance":[]}},"nbformat":4,"nbformat_minor":5}